# NetCode 호환성 분석 - 요약본

**프로젝트:** MeowDish
**분석 날짜:** 2025-11-18
**분석 대상:** 6개 ECS 시스템 + 14개 컴포넌트
**전체 평가:** 어려운 마이그레이션 필요 (약 153시간 예상)

---

## 빠른 현황

| 시스템 | 상태 | 난이도 | 우선순위 |
|--------|------|--------|----------|
| **PlayerMovementSystem** | ⚠️ 수정 필요 | 중간 | P1 |
| **PlayerAnimationSystem** | ⚠️ 수정 필요 | 쉬움 | P2 |
| **PlayerInputSystem** | ❌ 재작성 | 어려움 | P1 |
| **InteractionSystem** | ❌ 재작성 | 어려움 | P3 |
| **ContainerSystem** | ❌ 재작성 | 어려움 | P2 |
| **ItemVisualSystem** | ❌ 재작성 | 어려움 | P4 |

---

## 🚨 3가지 크리티컬 블로커

### 1. 아이템 ID 생성 (크리티컬)
```
문제:
  private int _nextItemID = 1;  // 각 클라이언트마다 독립적으로 증가

결과:
  클라이언트 A가 아이템 생성 → ID=5
  클라이언트 B가 아이템 생성 → ID=5
  서버가 아이템 생성 → ID=6
  ❌ 네트워크 동기화 실패!

해결책:
  서버가 모든 아이템 ID 생성
  서버가 ItemCreated 이벤트 브로드캐스트
  모든 클라이언트가 동일한 ID 수신
```

### 2. 입력 처리 (크리티컬)
```
문제:
  Input.GetKey() → PlayerInputComponent → PlayerMovementSystem
  모든 시스템이 모든 클라이언트에서 실행됨

결과:
  "내 입력"과 "다른 플레이어 입력" 구분 불가능
  예측/롤백 불가능
  고스트 플레이어가 예측 불가능하게 움직임

해결책:
  LocalInputGatherSystem (클라이언트 전용, 입력 수집)
  PlayerMovementSystem이 InputCommand에서 읽음 (네트워크 동기화)
  예측 레이어가 클라이언트 이동 검증
```

### 3. GameObject 아키텍처 (크리티컬)
```
문제:
  ItemVisualSystem이 ECS 루프 내에서 GameObject 생성
  Dictionary<Entity, GameObject>는 네트워크로 동기화 불가

결과:
  아이템이 생성한 클라이언트에서만 보임
  비주얼 상태의 네트워크 복제 불가능

해결책:
  Graphics.DrawMesh()로 순수 ECS 렌더링
  또는 Entities.Graphics (DOTS 인스턴싱) 사용
  네트워크 시스템에 GameObject 참조 제거
```

---

## 단계별 구현 계획

### Phase 1: 기초 작업 (1주차)
**작업량:** 15시간

네트워크 컴포넌트 생성:
- NetworkOwner (소유권 추적)
- NetworkEntity (고유 ID)
- LocalPlayerTag (소유자와 고스트 구분)

PlayerAuthoring에 추가하고 싱글플레이어가 여전히 작동하는지 확인.

### Phase 2: 입력 & 이동 (2-3주차)
**작업량:** 20시간

- PlayerInputSystem 분리 → LocalInputGatherSystem
- PlayerMovementSystem에 NetworkOwner 체크 추가
- 예측/롤백 메커니즘 테스트

**우선순위:** 높음 - 모든 게임플레이를 막음

### Phase 3: 아이템 시스템 (3-4주차)
**작업량:** 20시간

- 서버 권한 아이템 생성 구현
- TakeItemRequestRpc → ServerItemAuthority → ItemCreatedEvent 생성
- 모든 클라이언트에 아이템 ID 동기화

**우선순위:** 높음 - 크리티컬 동기화 오류 수정

### Phase 4: 렌더링 (4-5주차)
**작업량:** 24시간

- ItemVisualSystem에서 GameObject 생성 제거
- Graphics.DrawMesh() 렌더링 구현
- 고스트 플레이어 시각화 추가

**우선순위:** 중간 - 비주얼 폴리싱

### Phase 5: 상호작용 (5-6주차)
**작업량:** 24시간

- 서버 권한 상호작용 검증
- InteractionRequestRpc → ServerInteractionAuthority → Event
- 동시 상호작용 처리

**우선순위:** 중간 - 게임플레이 완성도

### Phase 6: 테스트 & 폴리싱 (6-7주차)
**작업량:** 30시간

- 각 시스템별 유닛 테스트
- 네트워크 통합 테스트 (2 클라이언트 + 서버)
- 레이턴시/렉/예측 롤백 테스트
- NetCode 성능 프로파일링

**우선순위:** 높음 - 프로덕션 준비도

---

## 재사용 가능한 것

✅ **핵심 ECS 아키텍처** - 좋은 기반
✅ **PlayerMovementSystem 로직** - 소유권 체크만 추가하면 됨
✅ **PlayerAnimationSystem 로직** - 이동 기반 입력만 추가하면 됨
✅ **PlayerStatsComponent** - 순수 데이터, 결정론적
✅ **ItemComponent** - 좋은 데이터 구조
✅ **HoldableComponent** - 간단한 참조

---

## 재작성이 필요한 것

❌ **PlayerInputSystem** - NetCode와 완전히 비호환
❌ **ContainerSystem** - 아이템 ID 생성이 멀티플레이어를 망가뜨림
❌ **InteractionSystem** - 서버 권한 없음
❌ **ItemVisualSystem** - GameObject 커플링이 복제 방해
❌ **네트워크 아키텍처** - 아직 존재하지 않음 (30시간)

---

## 현재 코드에서 배운 교훈

### ✅ 발견된 좋은 관행
1. **Burst 컴파일** - PlayerMovementSystem이 [BurstCompile] 사용
2. **결정론적 수학** - Random 사용 없음, 모든 수학이 예측 가능
3. **EntityCommandBuffer** - 지연 업데이트의 좋은 패턴
4. **컴포넌트 기반 설계** - 데이터와 로직 분리
5. **시스템 조직화** - 명확한 그룹과 의존성

### ❌ 수정할 문제점
1. **MonoBehaviour 시스템** - PlayerInputSystem이 ISystem struct가 아님
2. **GameObject 커플링** - ItemVisualSystem이 GameObject 생성
3. **GameObject.Find()** - 신뢰성 낮고 느림
4. **네트워크 개념 없음** - 소유권, 권한, 예측 없음
5. **비결정론적 ID** - 클라이언트별 정적 카운터
6. **직접 상태 변경** - 검증이나 RPC 패턴 없음

---

## 추천 접근법

**작게 시작:**
1. 1-2일차: 네트워크 컴포넌트 생성, PlayerAuthoring에 추가
2. 3-4일차: PlayerMovementSystem에 NetworkOwner 체크 추가
3. 5-7일차: ServerItemAuthority + ClientItemSync 생성 (아이템 동기화 테스트)

**그 다음 확장:**
4. 2주차: ID 동기화를 포함한 전체 아이템 시스템
5. 3주차: 입력 시스템 리팩토링 + 예측
6. 4주차: 렌더링 마이그레이션

**마지막 폴리싱:**
7. 5주차: 상호작용 시스템
8. 6주차: 테스트 & 성능

---

## 예상 타임라인

| 단계 | 기간 | 팀 규모 | 리스크 |
|------|------|---------|--------|
| 기초 작업 | 1주 | 1명 | 낮음 |
| 입력 & 이동 | 2주 | 1명 | 중간 |
| 아이템 시스템 | 2주 | 1명 | 높음 |
| 렌더링 | 1-2주 | 1명 | 중간 |
| 상호작용 | 1-2주 | 1명 | 높음 |
| 테스트 | 1-2주 | 2명 | 높음 |
| **전체** | **6-8주** | **1-2명** | **중간** |

---

## 다음 단계

1. **검토** 상세 분석 문서들
2. **생성** NetworkOwner & NetworkEntity 컴포넌트
3. **마이그레이션** PlayerMovementSystem (가장 간단, 게임플레이 영향 없음)
4. **테스트** 싱글플레이어가 여전히 작동하는지
5. **반복** 제공된 템플릿을 사용하여 나머지 시스템들

---

## 제공된 문서

1. **넷코드_상세분석.md** - 시스템별 상세 분석
2. **넷코드_아키텍처_비교.md** - 현재 vs 필요한 아키텍처
3. **넷코드_구현_템플릿.md** - 코드 예제와 패턴
4. **이 파일** - 요약본

총 문서량: 약 80페이지의 가이드와 예제.

---

## 💡 핵심 요점

### 현재 상태:
- ✅ 견고한 ECS 기반
- ✅ 싱글플레이어에 최적화됨
- ❌ 멀티플레이어 개념 없음

### 필요한 작업:
- 🔧 67%의 시스템 재작성
- 🚨 3가지 크리티컬 블로커
- ⏰ 6-8주 작업 시간
- 🎯 중간 난이도 및 리스크

### 의사결정 포인트:
**질문:** 멀티플레이어가 6-8주의 개발 시간을 투자할 가치가 있는가?

**고려사항:**
- 게임 비전에 멀티플레이어가 핵심인가?
- 싱글플레이어로 먼저 출시하고 나중에 멀티 추가?
- 개발 리소스와 타임라인은?

---

**행운을 빕니다!** 🚀
